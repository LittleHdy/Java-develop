分布式锁




redis分布式锁进化史
1.set : 多个线程同时set都是可以成功?
2.setnx : 它是 setifnotexist的缩写，也就是如果不存在就set. 问题是获取锁的这个客户端断线了就不会释放锁了
3.setnx + setex : 这是两条独立的命令,在setnx获取到锁之后再执行setex设置过期时间. 问题是如果setnx之后setex之前这个客户端就断线了同样不会释放锁
4.set nx ex : 合并成一条命令. 问题是释放锁只要简单地执行 del xxx即可，并不会检查这个锁是不是当前客户端获取到的。
5.random value + lua script : 加锁的时候，设置随机值，保证这个随机值只有当前客户端自己知道。
释放锁的时候，执行一段lua脚本，把这段lua脚本当成一个完整的命令，先检查这个锁对应的值是不是上面设置的随机值，如果是再执行del释放锁，否则直接返回释放锁失败。
问题是过期时间设置成多少合适?设置得过小, 有可能上一个线程不没有完成锁内逻辑就自动释放锁了,异常另一个线程获取到锁就出现并发问题了;设置过大,可能一个线程内的
逻辑很快执行完成, 这个锁要等很长一段时间
6.redisson(redis2.8+) : 自动启动一个监听线程处理续期,线程内的逻辑处理没有完成就一直续期,直到逻辑处理完成就释放锁