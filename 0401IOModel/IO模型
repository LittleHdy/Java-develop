
IO模型
https://www.cnblogs.com/tong-yuan/p/11854235.html

何为IO模型
对于一次IO操作，数据会先拷贝到内核空间中，然后再从内核空间拷贝到用户空间中，所以一次read操作，会经历两个阶段：
（1）等待数据准备
（2）数据从内核空间拷贝到用户空间

阻塞IO: 两阶段一起阻塞
从进程发起IO操作，一直等待上述两个阶段完成。

非阻塞IO: 第一阶段不阻塞但要轮询，第二阶段阻塞
进程一直询问IO准备好了没有，准备好了再发起读取操作，这时才把数据从内核空间拷贝到用户空间。

多路复用IO: 两阶段分开阻塞
多个连接使用同一个select去询问IO准备好了没有，如果有准备好了的，就返回有数据准备好了，然后对应的连接再发起读取操作，把数据从内核空间拷贝到用户空间。

信号驱动IO: 第一阶段不阻塞，第二阶段阻塞
进程发起读取操作会立即返回，当数据准备好了会以通知的形式告诉进程，进程再发起读取操作，把数据从内核空间拷贝到用户空间。

异步IO: 两个阶段都不阻塞
进程发起读取操作会立即返回，等到数据准备好且已经拷贝到用户空间了再通知进程拿数据。

同步非同步的区别在于调用操作系统的recvfrom()的时候是否阻塞，可见除了最后的异步IO其它都是同步IO。


select poll epoll
select 有最大文件描述符的限制，只能监听到有几个文件描述符就绪了，得遍历所有文件描述符获取就绪的IO。
poll 没有最大文件描述符的限制，与select一样，只能监听到有几个文件描述符就绪了，得遍历所有文件描述符获取就绪的IO。
epoll 没有最大文件描述符的限制，它通过回调的机制，一旦某个文件描述符就绪了，迅速激活这个文件描述符，当进程下一次调用epoll_wait()的时候便得到通知。
所以，在有大量空闲连接的时候，epoll的效率要高很多。


Java中的nio实际上是new io的缩写，它使用的是多路复用的IO模型。实际上Java只支持其中的三种，即BIO/NIO/AIO。